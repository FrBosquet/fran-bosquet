---
title: Optimizando im치genes para la web
description: Next nos ofrece una serie de mecanismos para optimizar las im치genes que utilizamos en nuestras aplicaciones web. Vamos a ver c칩mo.
date: 6-03-2024
published: true
keywords:
  - next
  - webp
  - cumulative layout shift
  - scripting
image:
  src: 'images'
  author: 'H칠ctor J. Rivas'
  authorUrl: 'https://unsplash.com/es/@hjrc33'
  source: 'Unsplash'
  sourceUrl: 'https://unsplash.com/es/fotos/lote-de-carteles-emblematicos-QNc9tTNHRyI'
---

He estado d치ndole una vuelta a **como uso las im치genes en este blog**. Hasta el momento el proceso ven칤a resultando bastante traum치tico. Me d칤 cuenta de esto en un momento en el que me vi en la tesitura de a침adir una nueva imagen y sent칤 una pereza infinita. Lo cual me llevo a reflexionar:

<YoutubeEmbed
  embedId="GU3M4ndorVI?start=18&end=25"
  title="Es que eso no puede hacerlo otro"
/>

Bueno, otro no, tendr칠 que hacerlo yo. Pero puedo automatizar con un script la parte tediosa de optimizar las im치genes y no volver a pensar en ello. Los pasos que ten칤a que hacer hasta ahora cada vez que quer칤a a침adir una nueva imagen:

- Convertirla a formato [webp](https://es.wikipedia.org/wiki/WebP), un formato sin p칠rdida de calidad, que reduce el tama침o de las im치genes considerablemente y que est치 desarrollando Google precisamente para su uso en webs.

- Redimensionarla al m치ximo tama침o que se va a mostrar, en el caso de esta web a 700px de ancho. Con el objetivo de tener la mejor calidad posible mandando la menor cantidad de datos.

- Finalmente, introducir la ruta de la imagen en el _markdown_, incluyendo la carpeta y la extensi칩n, que siempre son la misma (**images** y **.webp** respectivamente).

Por otro lado, con el _aproach_ actual a parte de frustraci칩n vengo echando en falta dos funcionalidades que el component Image de Next nos da gratis:

- Por un lado, el _lazy loading_: No descargar la imagen hasta que no este pr칩xima a aparecer en la p치gina a causa del scroll que haga el usuario. Hasta ahora todas las im치genes se cargaban al acceder a la p치gina, generando una carga en el dispositivo y en la red innecesaria.

- Mientras las im치genes no se han descargado, mostrar una versi칩n de la misma en baja resoluci칩n y calidad a modo de _placeholder_. Esto cumple dos funciones: Por un lado indicar visualmente que la imagen se esta cargando si por circunstancias de la red esta descarga toma el suficiente tiempo como para que el usuario vea el placeholder. Y ocupar el espacio que la imagen final vaya a ocupar, antes de que esta se descargue. De modo que evitamos que el contenido se vea desplazado por esta al descargarse provocando el denominado _layout shift_

Para esto 칰ltimo vamos a necesitar saber de antemano cual es el tama침o de la imagen y adem치s haber generado el placeholder con antelaci칩n. Como vamos a automatizar la gesti칩n de las im치genes, aprovecharemos tambi칠n para afrontar estas dos tareas con el _script_ que vamos a escribir.

## El proceso que ven칤a haciendo hasta ahora

Como he comentado en alguna ocasi칩n, utilizo una **maquina Windows con WSL2 corriendo Ubuntu** para desarrollar:

![Setup de ordenador@Mi estaci칩n de trabajo](computer)

**WSL** es b치sicamente una m치quina virtual altamente integrada en el sistema que permite asimilar un subsistema **Linux** dentro de un sistema operativo **Windows**. Gracias a esta tecnolog칤a tienes acceso a una terminal en la que puedes instalar y correr cualquier cosa que correr칤a en un **Ubuntu**, **Debian**, **Arch**, etc, pero dentro de tu sistema operativo de **Microsoft**. Utilizando tu IDE, tu terminal o tu explorador de archivos nativo a traves de t칰neles que, en la versi칩n actual, son pr치cticamente imperceptibles para el usuario.

Esta maravilla de la tecnolog칤a me permite **tener en Windows una experiencia de desarrollo casi 1:1 con la que tengo en un sistema Linux o Mac**, pudiendo aprovechar el PC Gaming que principalmente uso para jugar (칔nica tarea en la que el sistema de microsoft aun es muy superior a **OSX**, **Debian**, **Ubuntu**, etc.) para trabajar en mis proyectos de desarrollo en un entorno id칠ntico al que uso en el trabajo (terminal Unix).

**WSL** expone los puertos de los servicios que est칠s corriendo, asi que puedes correr una aplicaci칩n web y visitarla desde tu navegador. Puedes instalar aplicaciones gr치ficas como **GIMP** usando snap y utilizarlas desde el escritorio sin problemas. Puedes navegar el sistema de carpetas y gestionar los archivos desde el _explorer_ de **Windows**. Esto 칰ltimo es importante para el tema que nos ocupa, dado que los archivos est치ticos (im치genes) los descargo o las genero desde el sistema anfitri칩n y necesito copiarlas al subsistema **Linux**. En primeras versiones de **WSL** esto era un autentico suplicio. A d칤a de hoy puedes abrir el sistema de archivos de **WSL** desde el explorador de Windows como si de una partici칩n se tratara y copiar y pegar archivos sin problemas. Incluso arrastrando desde tu navegador a el explorador de archivos de **VsCode** (Que se conecta al entorno de desarrollo de **WSL**) puedes copiar archivos.

Volviendo al que era mi proceso hasta ahora, este consist칤a en:

- Copiar la imagen que quisiera usar en el blog a la carpeta de im치genes de mi proyecto, en este caso `/public/images`. **Next** expone como archivos est치ticos todo lo que pongas en la carpeta `/public` por lo que puedo acceder a las im치genes desde cualquier parte de mi aplicaci칩n simplemente referenciando a `/images/nombre-de-la-imagen.extension-de-la-imagen`.

- Utilizar un conversor a webp para convertir la imagen a ese formato. En mi caso utilizaba [cwebp](https://developers.google.com/speed/webp/docs/cwebp) que es la herramienta de Google para convertir im치genes a webp. Desde la terminal:

```bash
cwebp nombre-de-la-imagen.extension-de-la-imagen -o nombre-de-la-imagen.webp
```

- Utilizar la imagen en el Markdown:

```markdown
![Texto alternativo](/images/nombre-de-la-imagen.webp)
```

Lo cual es un proceso que me produc칤a pereza cada vez que ten칤a que a침adir una imagen. Copiar un archivo, ejecutar un comando y escribir una ruta completa puede parecer poca cosa pero cuando estas escribiendo puede romperte totalmente el ritmo hacerlo cada pocos minutos. Por otro lado, esta el tema del tama침o de las im치genes. Next se encarga de sobredimensionarlas al vuelo si usas el componente `Image`, pero para ello tienes que especificar el tama침o final de la imagen con un `width` y un `height`.

Si no lo haces, puedes usar la propiedad `fill` y especificar el tama침o en el contenedor con **CSS**, pero en mi caso me encontraba con la problem치tica de que tengo im치genes que llenan la columna (700px de ancho o mas) y otras que no y que quer칤a que quedaran centradas. Esto 칰ltimo no se puede hacer con `fill` y, ademas, pierdes la optimizaci칩n que hace Next de las im치genes puesto que no sabe a qu칠 tama침o debe dimensionarlas.

Total, que en un principio opt칠 por no calentarme la cabeza y usar el elemento `img` nativo de **HTML**, ya que este descarga la imagen y por defecto la muestra a su resoluci칩n nativa. Pero esto me causaba un tercer problema: El espacio no se ocupa hasta que la imagen se descarga, por lo que el _layout_ de la p치gina se va modificando conforme se completa la transferencia de los _assets_: b치sicamente, tu p치gina da "saltos" y esto queda horroroso. Esto es lo que conocemos como _layout shift_

Haber convivido con esta p칠sima experiencia de desarrollo que ademas me daba un resultado suboptimo durante tantos meses me ha terminado armando de valor para ponerme el mandil de _scripter_ y arreglar la problem치tica de las im치genes en este blog de una vez por todas.

## El script optimizador

Vamos a usar `zsh` para crear este _script_. Nos va a permitir navegar nuestro sistema de archivos y usar aplicaciones de terminal para automatizar tareas. Podr칤amos optar por otro lenguaje y entorno de ejecuci칩n, por ejemplo **Typescript** en **Node**. Pero me parece interesante practicar con la terminal, dado que siempre vas a tener _shell_ disponible en un sistema **Linux** y quien sabe cuando vas a tener que conectarte con _ssh_ a un contenedor **docker** para automatizar una tarea. As칤 que vamos a hacer el esfuerzo y a aprender un par de cosas con este _post_. Punto por punto:

### Copiar las im치genes a la m치quina Linux

Esto obviamente no lo podemos autom치tizar, simplemente es arrastrar y soltar la imagen que quiera. Pero hay una peque침a molestia que si que nos podemos quitar. Al copiar y pegar un archivo de **Windows** al subsistema **Linux**, este 칰ltimo crea un archivo `:Zone.Identifier` para almacenar meta informaci칩n. 쮺ual? Por ejemplo:

```@imagen:Zone.Identifier
[ZoneTransfer]
ZoneId=3
ReferrerUrl=https://photos.google.com/
HostUrl=about:internet
```

쯇or qu칠? No lo s칠 쯉e puede evitar? No he encontrado como. As칤 que lo que me tocaba hacer era borrar ese archivo cada vez que copiaba una nueva imagen al repositorio. Vamos a automatizar este proceso en el script:

```bash@public/images/process-images.sh
#!/bin/sh

rm -f "$(dirname "$0")"/*.Identifier
```

`#!/bin/sh` indica al sistema c칩mo debe ejecutar este archivo. Esto es muy interesante ya que podemos, por ejemplo, copiar el _script_ a la carpeta `usr/bin` y usarlo en cualquier lugar de nuestro sistema simplemente invocando su nombre. Es una manera genial de generar peque침as aplicaciones para personalizar tu sistema.

`rm -f` fuerza la eliminaci칩n de archivos, `"$(dirname "$0")"` hace referencia a la carpeta donde se encuentra el script e `*.Identifier` captura todos los archivos que terminen en `.Identifier`. Con esto ya nos hemos librado de esos molestos y no solicitados metadatos.

### Transformar las im치genes a webp

Lo normal es que las im치genes que copio, dependiendo del origen, sean `jpg` o `png`. Por ello necesito analizar la carpeta en busca de todos los archivos que no sean y치 `.webp` para procesarlos:

```bash@public/images/process-images.sh
...

for file in $(find "$(dirname "$0")" -type f ! -name "*.webp" ! -name "*.sh")
do
    cwebp -q 80 "$file" -o "${file%.*}.webp"

    rm "$file"
done
```

El bucle `for` recorre todos los archivos capturados por `find "$(dirname "$0")" -type f ! -name "*.webp" ! -name "*.sh"`:

- `find "$(dirname "$0")"` busca en la carpeta donde se encuentra el script.

- `-type f` captura solo archivos.

- `! -name "*.webp"` excluye los archivos que terminen en `.webp`, as칤 no procesaremos los que ya est칠n en ese formato.

- `! -name "*.sh"` excluye el propio script, ya que obviamente no es una imagen que quiera convertir.

Una vez que tenemos como valor de `$file` la ruta de la imagen, vamos a convertirla a webp con `cwebp -q 80 "$file" -o "${file%.*}.webp"`.

- `cwebp` es el comando que convierte las im치genes a webp. En **Ubuntu** puedes instalarlo con `sudo apt install webp`. Si utilizas otra distribuci칩n o sistema operativo, puedes buscar como hacerlo, suele ser muy sencillo.

- `-q 80` es la calidad de la imagen.

- `"$file"` es la referencia a la ruta de la imagen que queremos convertir, que obtuvimos en el bucle `for`.

- `-o "${file%.*}.webp"` es la ruta de salida de la imagen (`-o` de `--output`). `${file%.*}` es una forma de obtener el nombre del archivo sin la extensi칩n. Por ejemplo, si `$file` es `/ruta/a/imagen.jpg`, `${file%.*}` ser치 `/ruta/a/imagen`, a la cual a침adimos `.webp` para obtener la ruta de salida.

Finalmente, eliminamos la imagen original con `rm "$file"`, ya que una vez transformada en `webp` no necesitamos conservarla.

#### Redimendionar las im치genes

Lo siguiente es hacer un segundo bucle, ahora ya sobre los archivos `.webp` que hemos generado, y verificar si queremos redimensionarlos. En esta web, en escritorio, el ancho m치ximo al que mostramos las im치genes es de 700px. Para llevar a cabo este cometido, voy a usar la _suite_ de herramientas de [ImageMagick](https://imagemagick.org/index.php):

```bash@public/images/process-images.sh
for file in "$(dirname "$0")"/*.webp
do
  width=$(identify -format "%w" "${file%.*}.webp")

  # If the width is larger than 700px, resize the image
  if [ $width -gt 700 ]
  then
      mogrify -resize 700x "${file%.*}.webp"
  fi
```

- `for file in "$(dirname "$0")"/*.webp` es similar al bucle anterior, pero ahora capturamos solo los archivos `.webp` que hemos generado anteriormente y, ademas, al no usar `find` no recorreremos ninguna carpeta interna (Esto es importante dado que posteriormente vamos a crear una carpeta para _placeholders_ y no querremos recorrer su contenido).

- con `width=$(identify -format "%w" "${file%.*}.webp")` obtenemos el ancho de la imagen utilizando la utilidad `identify` de **ImageMagick**. con `-format "%w"` le decimos que lo que queremos es el ancho, y con `"${file%.*}.webp"` indicamos la ruta de la imagen. Guardamos el resultado una variable `$width`.

- `if [ $width -gt 700 ]` comprobamos si el ancho de la imagen es mayor a 700px. `$width` es la variable que definimos anteriormente, con el ancho de la imagen. `-gt` es un operador de comparaci칩n que significa "mayor que".

- Si se da el caso de que la imagen es mayor a 700px, redimensionamos la imagen con `mogrify -resize 700x "${file%.*}.webp"`. `mogrify` es otra utilidad de **ImageMagick** que permite modificar im치genes. Con `-resize 700x` le decimos que queremos redimensionar la imagen a un ancho de 700px, el alto lo dejamos implicito y se mantendra la misma relaci칩n de aspecto. Y con `"${file%.*}.webp"` le indicamos la ruta de la imagen.

Y con esas pocas lineas, hemos redimensionado todas las im치genes que superen los 700px de ancho. Las que no lo hicieran, no se han tocado.

#### Generar los placeholders

A continuaci칩n generaremos los _placeholders_. Estos van a ser versiones de poca resoluci칩n y poca calidad que vamos a utilizar para mostrar mientras se descargan las im치genes finales. Tenemos que crear im치gnes que recuerden a las finales, pero que ocupen unos poco bytes, para que podamos cargarlas casi instantaneamente incluso en condiciones de red poco favorables:

```bash@public/images/process-images.sh
  base=$(basename "$file")
  placeholderPath=$(dirname "$0")/placeholder/${base}

  if [ ! -f "$placeholderPath" ]; then
    convert "${file%.*}.webp" -blur 0x8 -quality 10 -resize 10x "$placeholderPath"
  fi
```

- Con `base=$(basename "$file")` obtenemos el nombre del archivo sin la ruta usando `basename` y lo guardamos en la variable `$base`.

- `placeholderPath=$(dirname "$0")/placeholder/${base}` es la ruta donde vamos a guardar el placeholder. `$(dirname "$0")` es la carpeta donde se encuentra el script, `/placeholder/` es una carpeta que tenemos que crear dentro de la carpeta `images` y `$base` es el nombre del archivo que definimos antes.

- `if [ ! -f "$placeholderPath" ]; then` comprobamos si el placeholder no existe. Con esto evitamos estar creando constantemente los mismos placeholders. Solo lo haremos con aquellos que nos falten. Esto es lo mismo que hac칤amos para redimensionar las imagenes a 700px de ancho.

- `convert "${file%.*}.webp" -blur 0x8 -quality 10 -resize 10x "$placeholderPath"` es la orden que genera el placeholder. `convert` es otra utilidad de **ImageMagick** que permite convertir imagenes. La diferencia con `mogrify` es que este modifica el original, mientras que `convert` crea una copia. `"${file%.*}.webp"` es la ruta de la imagen original, `-blur 0x8` desenfoca la imagen en un area de 8 pixeles, `-quality 10` indica una calidad baja (10 sobre 100), `-resize 10x` la redimensiona a 10px de ancho y `$placeholderPath` es la ruta de salida que definimos antes.

Y con solo esa linea, hemos creado los placeholders.

#### Guardar las dimensiones de las imagenes

Una vez tenemos la imagen redimensionada, necesito almacenar su tama침o para poder indicarle despu칠s al navegador cuanto espacio ocupar치 la misma. Si tan solo mandamos la _url_ del recurso al navegador, este no va a saber cual es el tama침o de la imagen hasta que no la haya descargado, por lo que vamos a sufrir seguro de [cumulative layout shifts](https://www.semrush.com/blog/cumulative-layout-shift/?kw=&cmp=ES_SRCH_DSA_Blog_EN&label=dsa_pagefeed&Network=g&Device=c&kwid=aud-2090387876853:dsa-2185834088336&cmpid=18347529021&agpid=153587537679&BU=Core&extid=137165264856&adpos=). David Walsh public칩 hace poco [un art칤culo](https://davidwalsh.name/fixing-cumulative-layout-shift-problems-on-davidwalshblog) (curiosamente en tercera persona) sobre como sufr칤a de este problema en su popular blog, como lo detect칩 y como lo solucion칩. _TLDR_: Lo solucion칩 **WordPress** por el. Aqu칤 no hay **Wordpress** que valga. En todo caso, **YO soy el WordPress**. Por lo que necesito almacenar las dimensiones de imagen para poder indicar al navegador desde el lado del servidor cuanto espacio vamos a necesitar para cada una de ellas.

Ya hemos visto como obtener el tama침o de la imagen con `identify`, ahora necesitamos almacenar esa informaci칩n en un archivo `json` que podamos leer desde el servidor al generar la p치gina. Para empezar, vamos a crear un archivo `.json` con una apertura de llaves en el inicio de nuestro script:

```bash@public/images/process-images.sh
echo "{" > "$(dirname "$0")/temp_image_sizes.json"
```

Usando `>` estamos indicando que queremos sobreescribir el archivo si ya existe.

A continuaci칩n, dentro del segundo bucle donde recorremos las imagenes y las redimensionamos, vamos a usar `identify` tal y como hicimos antes para obtener el ancho y alto del archivo ya redimensionado:

```bash@public/images/process-images.sh
  # Read the height and width of the resized image
  width=$(identify -format "%w" "${file%.*}.webp")
  height=$(identify -format "%h" "${file%.*}.webp")
```

Y vamos a a침adir esa informaci칩n en formato `json` al archivo que hemos creado:

```bash@public/images/process-images.sh
    # Append the image size to the image_sizes.json file
  echo "\"${base%.*}\": {\"width\": $width, \"height\": $height}," >> "$(dirname "$0")/temp_image_sizes.json"
```

Con `${base%.*}` eliminamos la extensi칩n del nombre del archivo y lo usamos como clave en el objeto `json`. A continuaci칩n, a침adimos el ancho y el alto de la imagen al archivo que hemos creado usando `>>` en lugar de `>`, de modo que en lugar de sobrescribir, a침adimos una nueva linea.

Una vez fuera del bucle, tenemos que tener en cuenta que el formato json no admite `coma de cola`: No podemos a침adir una coma al final del 칰ltimo elemento de un objeto. Por lo que vamos a eliminar la coma de la 칰ltima linea con `sed`:

```bash@public/images/process-images.sh
sed -i '$ s/,$//' "$(dirname "$0")/temp_image_sizes.json"
```

Y finalmente cerramos el objeto JSON con una llave de cierre, copiamos su contenido a un archivo definitivo y eliminamos el archivo temporal:

```bash@public/images/process-images.sh
echo "}" >> "$(dirname "$0")/temp_image_sizes.json"
cat "$(dirname "$0")/temp_image_sizes.json" > "$(dirname "$0")/image_sizes.json"
rm "$(dirname "$0")/temp_image_sizes.json"pnpm run dev
```

> He usado un archivo temporal por un motivo muy sencillo: **Webpack** va a estar escuchando cambios en el archivo JSON definitivo y a recargar la p치gina cada vez que los encuentre. La idea es escribir cada linea del _JSON_ conforme vayamos analizando imagen por imagen. Si escribi칠semos directamente en el _JSON_ que usamos al generar la web, **Webpack** detectar칤a un cambio en un archivo importado y regenerar칤a con un archivo _JSON_ incompleto (Sin llave de cierre, por lo que fallar칤a el parseo como **JSON**), rompiendo el render de la p치gina. Todo ello tantas veces como im치genes tengamos, cada vez que corriese el script. En resumen: Que a침adir una imagen nueva al repositorio romper칤a el servidor de desarrollo.
>
> Por ese motivo utilizo un _JSON_ temporal y, solo cuando est치 completo, copio su contenido al definitivo, asegurando que Webpack siempre l칠a un _JSON_ bien formado :thumbsup: Si te preguntas por qu칠 el temporal no rompe el servidor, ning칰n archivo de la aplicaci칩n importa ese temporal, por lo que para **Webpack** ese archivo no existe.

#### El script

Y as칤 queda nuestro script terminado:

```bash@public/images/process-images.sh
#!/bin/sh
rm -f "$(dirname "$0")"/*.Identifier

# Clean up a file name image_sizes.json
echo "{" > "$(dirname "$0")/temp_image_sizes.json"

# Loop through all files in the current directory
for file in $(find "$(dirname "$0")" -type f ! -name "*.webp" ! -name "*.sh" ! -name "*.json")
do
    # Use cwebp to convert the file to webp format
    cwebp -q 80 "$file" -o "${file%.*}.webp"

    # Delete the original file
    rm "$file"
done

# Loop through all webp files in the current directory
for file in "$(dirname "$0")"/*.webp
do
  width=$(identify -format "%w" "${file%.*}.webp")

  # If the width is larger than 700px, resize the image
  if [ $width -gt 700 ]
  then
      mogrify -resize 700x "${file%.*}.webp"
  fi

  base=$(basename "$file")

  # Read the height and width of the resized image
  width=$(identify -format "%w" "${file%.*}.webp")
  height=$(identify -format "%h" "${file%.*}.webp")

  # Append the image size to the image_sizes.json file
  echo "\"${base%.*}\": {\"width\": $width, \"height\": $height}," >> "$(dirname "$0")/temp_image_sizes.json"

  # Create a placeholder image
  placeholderPath=$(dirname "$0")/placeholder/${base}

  if [ ! -f "$placeholderPath" ]; then
    echo "Creating placeholder for $file"
    convert "${file%.*}.webp" -blur 0x8 -quality 10 -resize 10x "$placeholderPath"
  fi
done

# Remove the last comma from the image_sizes.json file and close the JSON object
sed -i '$ s/,$//' "$(dirname "$0")/temp_image_sizes.json"
echo "}" >> "$(dirname "$0")/temp_image_sizes.json"

cat "$(dirname "$0")/temp_image_sizes.json" > "$(dirname "$0")/image_sizes.json"
rm "$(dirname "$0")/temp_image_sizes.json"pnpm run dev
```

Da un gusto tremendo verlo funcionar, modificando y creando im치genes al vuelo, convirtiendo una tarea tediosa en unos pocos milisegundos de computaci칩n. Si bien conocer cada uno de los comandos requiere de mucha experiencia y la sintaxis de **bash** es bastante extra침a si vienes de un lenguaje inspirado en **C** (como lo es **javascript**), puedes valerte de una IA para ayudarte a desarrollar este tipo de utilidades.

En mi caso para crear el script simplemente he ido pidi칠ndole a **Copilot** lo que necesitaba hacer en cada momento: Buscar todas las im치genes no **.webp**, ignorar el propio _script_, comprobar el ancho, etc. Y el me iba dando el c칩digo en `bash`. El resultado no es precisamente el que hubiese escrito un ingeniero de sistemas, pero eso no es raz칩n para no aprovechar las posibilidades de tu maquina. Si como a m칤 el scripting de shell siempre te ha resultado esquivo, te recomiendo que le des una oportunidad a esta u otra IA que te ayude a ponerte en marcha. Con un poco ensayo y error puedes crear scripts para automatizar tareas pesadas, guardarlos en tu carpeta `/usr/local/bin` y extender muy f치cilmente tu sistema **Unix** para que haga exactamente lo que necesitas.

Otra opci칩n es crear un script con `Typescript` y ejecutarlo con `ts-node`. Esto te permite tener un _script_ m치s legible (para un desarrollador web al menos) y con la gran ventaja de poder usar `import` para usar librer칤as que uses en tu proyecto. Esto es muy util por ejemplo para realizar migraciones de base de datos. En una entrada futura te ense침ar칠 como hacerlo.

## Optimizando las im치genes en Next.js

La segunda parte de esta entrada la dedicaremos a usar apropiadamente las herramientas que **Next** nos provee en relaci칩n a las im치genes. Hasta ahora he estado esquivando el componente `Image` puesto que requiere especificar el tama침o de la imagen y 쯈uien tiene tiempo de mantener un trabajo a tiempo completo, mantener un blog y medir las im치genes a la vez?

Pero ahora que hemos automatizado el proceso, vamos a ver como podemos hacer uso de este componente para mostrar nuestras im치genes con _lazy loading_, _placeholders_ y el tama침o correcto antes y despu칠s de la carga evitando as칤 el temido `cumulative layout shift`.

En nuestro archivo `mdx-content.tsx` es donde especificamos c칩mo transformamos el contenido markdown en elementos html, definiendo componentes. Para las im치genes ven칤amos haciendo esto:

```tsx@components/mdx-content.tsx
const mdxComponents = {
  ...
    img: (props: any) => <img className="w-auto mb-1 m-auto" title={props.alt} alt={props.alt} src={props.src} />,
  ...
}
```

Cuando definimos una imagen en markdown, lo hacemos de la siguiente manera:

```markdown
![Texto alternativo](/images/nombre-de-la-imagen.webp)
```

En las props recibimos `Texto alternativo` como `props.alt` y `/images/nombre-de-la-imagen.webp` como `props.src`. Vamos a sustituir el componente `img` por el componente `Image` de Next:

```tsx@components/mdx-content.tsx
img: (props: any) => <Image
  className="w-auto mb-1 m-auto"
  alt={props.alt}
  src={props.src}
/>,
```

### Simplificando al m치ximo la definici칩n del src

Para facilitar el uso de im치genes y dado que todas se almacenan en la misma carpeta, vamos a asumir que la ruta solo especifica el nombre de la imagen, sin extensi칩n ni ruta, y vamos a componer nosotros mismos la ruta del recurso:

```tsx@components/mdx-content.tsx
img: (props: any) => <Image
  className="w-auto mb-1 m-auto"
  alt={props.alt}
  src={`/images/${props.src}.webp`}
/>,
```

De este modo, mientras escribo el post no tengo que a침adir ni la carpeta ni la extensi칩n, solo el nombre de la imagen.

> **Importante**: Este cambio me va a requerir refactorizar TODOS los posts. Por suerte para m칤, no tengo muchos 游땍.

### Especificar las dimensiones

Como `src` ahora es solo el nombre del archivo, coincide con la clave del objeto `json` que creamos en el _script_. Por lo que podemos usar esa informaci칩n para obtener el tama침o de la imagen y pas치rselo al componente `Image`:

```tsx@components/mdx-content.tsx
import imageSizes from 'public/images/image_sizes.json'

...

img: (props: any) => {
  const { width, height } = imageSizes[props.src as keyof typeof imageSizes]

  return <Image
    className="w-auto mb-1 m-auto"
    alt={props.alt}
    src={`/images/${props.src}.webp`}
    width={width}
    height={height}
  />
},
```

`keyof typeof` nos permite indicarle a **Typescript** que est칠 tranquilo, que `src` es una clave existente en el objeto `imageSizes`. De este modo estamos trasladando el error al tiempo de ejecuci칩n, lo cual no es necesariamente una buena pr치ctica. Pero en este caso espec칤fico se justifica por el hecho de que si la clave no existe es porque la hemos escrito m치l. Y dado que este es un componente que se ejecuta en el servidor, el tiempo de ejecuci칩n es, de hecho, tambi칠n el tiempo de compilaci칩n. Si usamos una clave n칩 valida, esa linea romper치 con una excepci칩n, por lo que no corremos riesgo de mandar im치genes inexistentes al navegador. De hecho, con esto hemos mejorado nuestro flujo de trabajo: Si una imagen no existe, el script de `build` va a romper y con ello impedir치 que una versi칩n rota de la p치gina se despliegue.

### Lazy loading

Vamos a indicarle a **Next** que no queremos cargar la imagen hasta que no est칠 cerca de entrar en el viewport. Con esto evitamos cargar todas las im치genes al principio y solo las cargamos cuando estamos cerca de mostrarlas. Para ello, vamos a a침adir la propiedad `loading="lazy"` al componente `Image`:

```tsx@components/mdx-content.tsx
img: (props: any) => {
  const { width, height } = imageSizes[props.src as keyof typeof imageSizes]

  return <Image
    className="w-auto mb-1 m-auto"
    alt={props.alt}
    src={`/images/${props.src}.webp`}
    width={width}
    height={height}
    loading="lazy"
  />
},
```

Puedes ir a un post con muchas im치genes (Por ejemplo [este](/posts/primer-dia-datadog)), abrir el inspector de elementos, pesta침a _network_, filtrar por imagenes: Podr치s ver c칩mo las imagenes solo se van descargando conforme vas haciendo scroll y te acercas a que sean visibles:

![Cargando imagenes a demanda](image_loading)

### Placeholder

A continuaci칩n vamos a a침adir el _placeholder_. Para ello, vamos a setear la propiedad `placeholder` a `blur` en el componente `Image`, y vamos especificar la ruta a la imagen que generamos anteriormente:

```tsx@components/mdx-content.tsx
    return <Image
      className="mb-1 m-auto"
      alt={props.alt}
      src={`/images/${props.src}.webp`}
      width={width}
      height={height}
      loading='lazy'
      placeholder='blur'
      blurDataURL={`/images/placeholder/${props.src}.webp`}
    />
```

Como hemos especificado dimensiones, si bien el placeholder tiene solo 10px de ancho, en el navegador se estirar치 a las dimensiones indicadas, evitando el `layout shift` y mostrando efectivamente un imagen en baja resoluci칩n mientras se carga la definitiva.

### Pies de foto

Por 칰ltimo, voy a solucionar el tema de los pies de foto. Hasta ahora he venido poniendo un texto en cursiva debajo de la imagen. A parte de no quedar muy all치:

![Pie de foto](imagefoot)

Tiene el problema de que no es accesible. Las personas con problemas de visi칩n no van a poder saber que ah칤 hay un pie de foto. Por lo que vamos a a침adir un `figcaption` a la imagen para dejar claro desde el punto de vista sem치ntico, y no solo visual, que se trata de un pi칠 de foto:

```tsx@components/mdx-content.tsx
    return <figure>
      <Image
        ...
      />
      <figcaption className='text-xs text-center text-slate-300'>{props.alt}</figcaption>
    </figure>
  }
```

Comparando lo anterior con lo nuevo:

![Pie de foto](figcaption)

Luce mejor, pero tenemos dos problemas:

- Como se ve en el ejemplo, **no siempre el alt y el pie de foto coinciden**

- Si lo dejo as칤, voy a asumir que todas las imagenes van a tener pie de foto, y esto no es as칤 en este blog. Por lo que me obligar칤a a actualizar todos los posts. De nuevo, no son muchos pero no me apetece revisarlos todos.

Por lo que **vamos a implementar un sistema que permita a침adir el pie de foto desde el markdown sin demasiada complicaci칩n**. Las reglas serian:

- Si nos encontramos una `@` en el texto alternativo, la foto tendr치 pie de foto. De este modo nos aseguramos de no romper la compatibilidad con los posts anteriores.

- Si nos encontramos la `@`, el texto que la precede ser치 el `akt` y el vaya detr치s de ella ser치 el pie de foto.

- Si nos encontramos la `@` pero no hay texto detr치s, el `alt` y el pie de foto ser치n el mismo.

Modifico una vez m치s el componente para a침adir la l칩gica descrita:

```tsx@components/mdx-content.tsx
  img: (props: any) => {
    const { width, height } = imageSizes[props.src as keyof typeof imageSizes]
    const [alt, caption] = props.alt.split('@')

    const hasCaption = caption !== undefined

    return <figure>
      <Image
        ...
      />
      {hasCaption
        ? <figcaption className='text-xs text-center text-slate-300'>{
          caption || alt
        }</figcaption>
        : null
      }
    </figure>
  }
```

Y ahora puedo modificar el markdown de esto:

```markdown
![Imagen de Muzzy](muzzy)
_Elige uno y arranca tu carrera como web-developer_
```

A esto:

```markdown
![Imagen de Muzzy@Elige uno y arranca tu carrera como web-developer](muzzy)
```

Y disfrutar de esos lindos y sem치nticos pies de foto:

![Pie de foto](figcaption_fixed)

> **OJO!** remark por defecto envuelve todos los elementos en un p치rrafo, as칤 que con este cambio estamos metiendo un figure dentro de p, lo cual es sem치nticamente incorrecto y nos da errores de hydration al mandar la p치gina al cliente.
>
> He tenido que echar un par de horas investigando el asunto y no quiero explicarlo aqu칤 ya que el post se ha vuelto ya demasiado largo. TLDR: Puedes usar un plugin de remark para evitar este comportamiento con imagenes, lo cual limpia el problema de raiz. Tengo [este commit](https://github.com/FrBosquet/fran-bosquet/commit/df13951de3ced8b251398f629fd33c0e50785552) en el que implemento esta soluci칩n y actualizo next-mdx-remote para usar RSC, aprovechando que he migrado a Next 14.
>
> Por la misma raz칩n, tampoco me he extendido en como he utilizado chokidar para monitorizar la carpeta images y correr el script autom치ticamente cada vez que a침ado una imagen, o como he actualizado el linter para facilitarme el trabajo. Si tienes inter칠s, puedes checkear la PR en Github y ver todo lo que se ha quedado fuera de este post.

## Conclusi칩n

Hemos aprendido a automatizar una tarea muy tediosa como es preparar las im치genes para usarlas en la web. Hemos simplificado la interfaz en MDX para que usarlas sea los m치s sencillo y accesible posible. Hemos mejorado la experiencia de usuario con lazy loading y placeholders. Y finalmente hemos mejorado la accesibilidad de las im치genes a침adiendo pies de foto sem치nticos.

En el camino hemos aprendido a usar algunas herramientas de terminal muy interesantes y hemos mejorado nuestro entendimiento de Next.

Si has llegado hasta aqu칤 despu칠s de semejante ladrillo, te doy las gracias por tu tiempo y espero que te hayas llevado algo de provecho. Hasta la pr칩xima!
