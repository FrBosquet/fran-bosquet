---
title: Optimizando imagenes para la web
description: Next nos ofrece una serie de mecanismos para optimizar las im치genes que utilizamos en nuestras aplicaciones web. Vamos a ver c칩mo.
date: 6-03-2024
published: true
keywords:
  - next
  - webp
  - images
image:
  src: 'images'
  author: 'H칠ctor J. Rivas'
  authorUrl: 'https://unsplash.com/es/@hjrc33'
  source: 'Unsplash'
  sourceUrl: 'https://unsplash.com/es/fotos/lote-de-carteles-emblematicos-QNc9tTNHRyI'
---

He estado d치ndole una vuelta a como uso las im치genes en este blog. Hasta el momento el proceso estaba resultando traum치tico. Me d칤 cuenta de esto en un momento en el que me vi en la tesitura de a침adir una nueva imagen y sent칤 una pereza infinita. Lo cual me llevo a reflexionar:

<YoutubeEmbed
  embedId="GU3M4ndorVI?start=18&end=25"
  title="Es que eso no puede hacerlo otro"
/>

Bueno, otro no, tendr칠 que hacerlo yo. Pero puedo automatizar con un script la parte tediosa de optimizar las imagenes y no volver a pensar en ello. A saber:

- Convertir las im치genes a formato [webp](https://es.wikipedia.org/wiki/WebP), un formato sin p칠rdida de calidad y que reduce el tama침o de las im치genes considerablemente y que est치 desarrollando Google precisamente para su uso en web.

- Redimensionar las im치genes al m치ximo tama침o que se van a mostrar. Esto no es necesario ya que **Next** se encarga de hacerlo autom치ticamente, pero ya que estamos prefiero tener im치genes de pocos Kbs antes que de Mbs.

- Introducir la ruta de la imagen en el markdown.

- Crear _placeholders_: Versiones de baja resoluci칩n, baja calidad y bajo tama침o para mostrar durante la carga.

Por otro lado, tenemos el component Image de **Next** que hasta ahora estaba obviando por pura vagancia. Vamos a introducirlo tambi칠n para hacer un uso incluso m치s eficiente de nuestras im치genes.

## El proceso que ven칤a haciendo hasta ahora

Como he comentado en alguna ocasi칩n, utilizo una maquina Windows con WSL2 corriendo Ubuntu para desarrollar:

![Mi juguete](computer)

WSL es b치sicamente una m치quina virtual altamente integrada en el sistema, por lo que tengo una terminal Linux en la que puedo instalar y correr cualquier cosa que correr칤a en un Ubuntu, como por ejemplo servicios Node como Next. Los puertos que exponen esos servicios se exponen a la m치quina anfitri칩n, por lo que puedo acceder a ellos desde el navegador de Windows. Esta maravilla de la tecnolog칤a permite tener en windows una experiencia de desarrollo casi 1:1 con la que tendr칤a en un sistema Linux o Mac, sin tener que renunciar a mi m치quina Windows.

Al igual que expone los puertos, tambi칠n comparte el sistema de archivos, por lo que puedo acceder a los archivos de mi proyecto desde Windows o desde Ubuntu. Esto es importante porque los archivos est치ticos (im치genes) las descargo o las genero desde el sistema anfitri칩n y necesito copiarlas al sistema Linux. En primeras versiones de WSL esto era un autentico suplicio. Por suerte a d칤a de hoy puedes abrir el sistema de archivos de WSL desde el explorador de Windows y copiar y pegar archivos sin problemas. Incluso arrastrando desde tu navegador a el explorador de archivos de VsCode (Que se conecta al entorno de desarrollo de WSL) puedes copiar archivos.

As칤 que mi proceso hasta ahora era:

- Copiar la imagen que quisiera usar en el blog a la carpeta de im치genes de mi proyecto, en este caso `/public/images`. Next expone como est치tico todo lo que pongas en la carpeta `/public` por lo que puedo acceder a las im치genes desde cualquier parte de mi aplicaci칩n simplemente referenciando a `/images/nombre-de-la-imagen.extension-de-la-imagen`.

- Utilizar un conversor a webp para convertir la imagen a ese formato. En mi caso utilizaba [cwebp](https://developers.google.com/speed/webp/docs/cwebp) que es la herramienta de Google para convertir im치genes a webp.

```bash
cwebp nombre-de-la-imagen.extension-de-la-imagen -o nombre-de-la-imagen.webp
```

- Utilizar la imagen en el Markdown:

```markdown
![Texto alternativo](/images/nombre-de-la-imagen.webp)
```

Lo cual tampoco es un gran drama, pero si que es un proceso que se me hac칤a tedioso y que me produc칤a pereza cada vez que ten칤a que a침adir una imagen. Por otro lado, esta el tema del tama침o de las im치genes. Next se encarga de sobredimensionarlas al vuelo si usas el componente `Image`, pero para ello tienes que especificar el tama침o final de la imagen con un `width` y un `height`.

Ademas, si empiezas a acumular im치genes de 6000x4000px en tu proyecto el tama침o de tu proyecto se dispara, lo cual no es un gran problema en este proyecto pero empieza a decelerar todo y no se si puede incluso disparar los costes de uso en Vercel si el proyecto empieza a tener visitas.

Por 칰ltimo, he notado 칰ltimamente que las im치genes tardan un poco en cargar en la home. Esto produce un efecto muy feo ya que dejan el hueco vacio y se van mostrando conforme se descargan. El componente `Image` de Next tiene una propiedad `placeholder` que permite mostrar una versi칩n de baja resoluci칩n de la imagen mientras se descarga la versi칩n final. Esto es muy 칰til para mejorar la experiencia de usuario ya que le mostraremos un esbozo de lo que estamos descargando.

Pero dichos placeholders hay que generarlos tambi칠n, por lo que otra tarea m치s que a침adir a la lista de tediosos procesos que tengo que hacer cada vez que a침ado una imagen.

As칤 que aqu칤 he trazado la linea. Voy a automatizar todo este proceso con un script que haga todo esto por mi.

## El script optimizador

Vamos a usar `sh` para crear este script. Nos va a permitir navegar nuestro sistema de archivos y usar aplicaciones de terminal de una manera mas sencilla que un script de Node. Vamos punto por punto:

### Copiar las imagenes a la m치quina Linux

Esto obviamente no lo podemos auto치tizar, simplemente es arrastrar y soltar. Pero hay una peque침a molestia que si que nos podemos quitar. Al copiar y pegar un archivo de Windows al subsistema Linux, este 칰ltimo crea un archivo `:Zone.Identifier` para almacenar metainformaci칩n. 쮺ual? Ejemplo:

```
[ZoneTransfer]
ZoneId=3
ReferrerUrl=https://photos.google.com/
HostUrl=about:internet
```

쯇or qu칠? No lo s칠 쯉e puede evitar? No he encontrado como. As칤 que lo que me toca hacer es borrar ese archivo cada vez que copio una nueva imagen. Vamos a automatizar este proceso en el script:

```bash@public/images/process-images.sh
#!/bin/sh

rm -f "$(dirname "$0")"/*.Identifier
```

`rm -f` fuerza la eliminaci칩n del archivo, `"$(dirname "$0")"` hace referencia a la carpeta donde se encuentra el script y `*.Identifier` captura todos los archivos que terminen en `.Identifier`. Con esto ya nos hemos librado de esos molestos metadatos

### Transformar las im치genes a webp

Lo normal es que las imagenes que copio, dependiendo del origen, sean `jpg` o `png`. Por ello necesito analizar la carpeta en busca de todos los archivos que no sean y치 `.webp` para procesarlos:

```bash@public/images/process-images.sh
...

for file in $(find "$(dirname "$0")" -type f ! -name "*.webp" ! -name "*.sh")
do
    cwebp -q 80 "$file" -o "${file%.*}.webp"

    rm "$file"
done
```

El bucle `for` recorre todos los archivos capturados por `find "$(dirname "$0")" -type f ! -name "*.webp" ! -name "*.sh"`:

- `find "$(dirname "$0")"` busca en la carpeta donde se encuentra el script.

- `-type f` captura solo archivos.

- `! -name "*.webp"` excluye los archivos que terminen en `.webp`, as칤 no procesaremos los que ya esten en ese formato.

- `! -name "*.sh"` excluye el propio script, ya que obviamente no es una imagen que quiera convertir.

Una vez que tenemos como valor de `$file` la ruta de la imagen, vamos a convertirla a webp con `cwebp -q 80 "$file" -o "${file%.*}.webp"`.

- `cwebp` es el comando que convierte las im치genes a webp. En Ubuntu puedes instalarlo con `sudo apt install webp`. Si utilizas otra distribuci칩n o sistema operativo, puedes buscar como hacerlo, suele ser muy sencillo.

- `-q 80` es la calidad de la imagen.

- `"$file"` es la referencia a la ruta de la imagen que queremos convertir, que obtuvimos en el bucle `for`.

- `-o "${file%.*}.webp"` es la ruta de salida de la imagen (`-o` de `--output`). `${file%.*}` es una forma de obtener el nombre del archivo sin la extensi칩n. Por ejemplo, si `$file` es `/ruta/a/imagen.jpg`, `${file%.*}` ser치 `/ruta/a/imagen`, a la cual a침adimos `.webp` para obtener la ruta de salida.

Finalmente, eliminamos la imagen original con `rm "$file"`, ya que una vez transformada en `webp` no necesitamos conservarla.

#### Redimendionar las im치genes

Lo siguiente es hacer un segundo bucle, ahora ya sobre los archivos `.webp` que hemos generado, y verificar si queremos redimensionarlos. En esta web, en escritorio, el ancho m치ximo al que mostramos las imagenes es de 700px. Para llevar a cabo este cometido, voy a usar la suite de herramientas de [ImageMagick](https://imagemagick.org/index.php):

```bash@public/images/process-images.sh
for file in "$(dirname "$0")"/*.webp
do
  width=$(identify -format "%w" "${file%.*}.webp")

  # If the width is larger than 700px, resize the image
  if [ $width -gt 700 ]
  then
      mogrify -resize 700x "${file%.*}.webp"
  fi
```

- `for file in "$(dirname "$0")"/*.webp` es similar al bucle anterior, pero ahora capturamos solo los archivos `.webp` que hemos generado anteriormente y, ademas, al no usar find no recorreremos ninguna carpeta interna (Esto es importante dado que posteriormente vamos a crear una carpeta para placeholders).

- con `width=$(identify -format "%w" "${file%.*}.webp")` obtenemos el ancho de la imagen utilizando la utilidad `identify` de **ImageMagick**. con `-format "%w"` le decimos que lo que queremos es el ancho, y con `"${file%.*}.webp"` indicamos la ruta de la imagen. Guardamos el resultado una variable `$width`.

- `if [ $width -gt 700 ]` comprobamos si el ancho de la imagen es mayor a 700px. `$width` es la variable que definimos anteriormente, con el ancho de la imagen. `-gt` es un operador de comparaci칩n que significa "mayor que".

- Si se da el caso de que la imagen es mayor a 700px, redimensionamos la imagen con `mogrify -resize 700x "${file%.*}.webp"`. `mogrify` es otra utilidad de **ImageMagick** que permite modificar im치genes. Con `-resize 700x` le decimos que queremos redimensionar la imagen a un ancho de 700px, el alto lo dejamos implicito y se mantendra la misma relaci칩n de aspecto. Y con `"${file%.*}.webp"` le indicamos la ruta de la imagen.

Y con esas pocas lineas, hemos redimensionado todas las im치genes que superen los 700px de ancho. Las que no lo hicieran, no se han tocado.

#### Generar los placeholders

Por 칰ltimo, vamos a generar los placeholders. Estos van a ser versiones de poca resoluci칩n y poca calidad que vamos a utilizar para mostrar mientras se descargan las im치genes finales. Tenemos que crear im치gnes que recuerden a las finales, pero que ocupen unos poco bytes, para que podamos cargarlas casi instantaneamente en condici칩n de red:

```bash@public/images/process-images.sh
  base=$(basename "$file")
  placeholderPath=$(dirname "$0")/placeholder/${base}

  if [ ! -f "$placeholderPath" ]; then
    convert "${file%.*}.webp" -blur 0x8 -quality 10 -resize 10x "$placeholderPath"
  fi
```

- Con `base=$(basename "$file")` obtenemos el nombre del archivo sin la ruta usando `basename` y lo guardamos en la variable `$base`.

- `placeholderPath=$(dirname "$0")/placeholder/${base}` es la ruta donde vamos a guardar el placeholder. `$(dirname "$0")` es la carpeta donde se encuentra el script, `/placeholder/` es una carpeta que tenemos que crear dentro de la carpeta `images` y `$base` es el nombre del archivo que definimos antes.

- `if [ ! -f "$placeholderPath" ]; then` comprobamos si el placeholder no existe. Con esto evitamos estar creando constantemente los mismos placeholders. Solo lo haremos con aquellos que nos falten. Esto es lo mismo que hac칤amos para redimensionar las imagenes a 700px de ancho.

- `convert "${file%.*}.webp" -blur 0x8 -quality 10 -resize 10x "$placeholderPath"` es la orden que genera el placeholder. `convert` es otra utilidad de **ImageMagick** que permite convertir imagenes. La diferencia con `mogrify` es que este modifica el original, mientras que convert crea una copia. `"${file%.*}.webp"` es la ruta de la imagen original, `-blur 0x8` desenfoca la imagen en un area de 8 pixeles, `-quality 10` indica una calidad baja (10 sobre 100), `-resize 10x` la redimensiona a 10px de ancho y `$placeholderPath` es la ruta de salida que definimos antes.

Y con solo esa linea, hemos creado los placeholders.

#### Guardar las dimensiones de las imagenes

Una vez tenemos la imagen redimensionada, necesito almacenar su tama침o para poder dimensionarla correctamente. Si tan solo mandamos la url del recurso al navegador, este no va a saber cual es el tama침o de la imagen hasta que no la haya descargado, por lo que vamos a sufrir casi seguro de [layout shifts](https://www.semrush.com/blog/cumulative-layout-shift/?kw=&cmp=ES_SRCH_DSA_Blog_EN&label=dsa_pagefeed&Network=g&Device=c&kwid=aud-2090387876853:dsa-2185834088336&cmpid=18347529021&agpid=153587537679&BU=Core&extid=137165264856&adpos=). Por lo que necesito almacenar esta informaci칩n para poder indicar desde el lado del servidor cuanto espacio vamos a necesitar.

Ya hemos visto como obtener el tama침o de la imagen con `identify`, ahora necesitamos almacenar esa informaci칩n en un archivo `json` que podamos leer desde el servidor al generar la p치gina. Para empezar, vamos a crear un archivo `.json` con una apertura de llaves en el inicio de nuestro script:

```bash@public/images/process-images.sh
echo "{" > "$(dirname "$0")/image_sizes.json"
```

Usando `>` estamos indicando que queremos sobreescribir el archivo si ya existe.

A continuaci칩n, dentro del segundo bucle donde recorremos las imagenes y las redimensionamos, vamos a usar `identify` tal y como hicimos antes para obtener el ancho y alto del archivo ya redimensionado:

```bash@public/images/process-images.sh
  # Read the height and width of the resized image
  width=$(identify -format "%w" "${file%.*}.webp")
  height=$(identify -format "%h" "${file%.*}.webp")
```

Y vamos a a침adir esa informaci칩n en formato `json` al archivo que hemos creado:

```bash@public/images/process-images.sh
    # Append the image size to the image_sizes.json file
  echo "\"${base%.*}\": {\"width\": $width, \"height\": $height}," >> "$(dirname "$0")/image_sizes.json"
```

Con `${base%.*}` eliminamos la extensi칩n del nombre del archivo y lo usamos como clave en el objeto `json`. A continuaci칩n, a침adimos el ancho y el alto de la imagen al archivo que hemos creado usando `>>` en lugar de `>`, de modo que en lugar de sobrescribir, a침adimos una nueva linea.

Una vez fuera del bucle, tenemos que tener en cuenta que el formato json no admite `coma de cola`: No podemos a침adir una coma al final del 칰ltimo elemento de un objeto. Por lo que vamos a eliminar la coma de la 칰ltima linea con `sed`:

```bash@public/images/process-images.sh
sed -i '$ s/,$//' "$(dirname "$0")/image_sizes.json"
```

Y finalmente cerramos el objeto `json` con una llave de cierre:

```bash@public/images/process-images.sh
echo "}" >> "$(dirname "$0")/image_sizes.json"
```

#### El script

Y as칤 queda nuestro script terminado

```bash@public/images/process-images.sh
rm -f "$(dirname "$0")"/*.Identifier

# Clean up a file name image_sizes.json
echo "{" > "$(dirname "$0")/image_sizes.json"

# Loop through all files in the current directory
for file in $(find "$(dirname "$0")" -type f ! -name "*.webp" ! -name "*.sh" ! -name "*.json")
do
  # Use cwebp to convert the file to webp format
  cwebp -q 80 "$file" -o "${file%.*}.webp"

  # Delete the original file
  rm "$file"
done

# Loop through all webp files in the current directory
for file in "$(dirname "$0")"/*.webp
do
width=$(identify -format "%w" "${file%.*}.webp")

# If the width is larger than 700px, resize the image
if [ $width -gt 700 ]
then
    mogrify -resize 700x "${file%.*}.webp"
fi

base=$(basename "$file")

# Read the height and width of the resized image
width=$(identify -format "%w" "${file%.*}.webp")
height=$(identify -format "%h" "${file%.*}.webp")

# Append the image size to the image_sizes.json file
echo "\"${base%.*}\": {\"width\": $width, \"height\": $height}," >> "$(dirname "$0")/image_sizes.json"

# Create a placeholder image
placeholderPath=$(dirname "$0")/placeholder/${base}

if [ ! -f "$placeholderPath" ]; then
  echo "Creating placeholder for $file"
  convert "${file%.*}.webp" -blur 0x8 -quality 10 -resize 10x "$placeholderPath"
fi
done

# Remove the last comma from the image_sizes.json file and close the JSON object
sed -i '$ s/,$//' "$(dirname "$0")/image_sizes.json"
echo "}" >> "$(dirname "$0")/image_sizes.json"
```

Da un gusto tremendo ver funcionar el script, modificando y creando im치genes al vuelo. Si bien conocer cada uno de los comandos requiere de mucha experiencia y la sintaxis de **bash** es bastante extra침a si vienes de un lenguaje inspirado en **C** (como lo es javascript), puedes valerte de una IA para ayudarte a desarrollarlo. En mi caso, para crear el script simplemente he ido pidi칠ndole a **copilot** lo que necesitaba hacer: Buscar todas las imagenes no **.webp**, ignorar el propio script, comprobar el ancho, etc. Y el me iba dando el c칩digo en `bash`. El resultado no es lo m치s profesional, pero si como a m칤 el scripting de shell siempre te ha resultado esquivo, te recomiendo que le des una oportunidad a esta u otra IA para ayudarte a poner en marcha. Con un poco de pr치ctica puedes crear scripts, guardarlos en tu carpeta bin y automatizar tareas de terminal muy f치cilmente en cualquier sistema Unix.

Otra opci칩n es crear un script con `Typescript` y ejecutarlo con `ts-node`. Esto te permite tener un script m치s legible (para un desarrollador web al menos) y con la posibilidad de usar `import` para usar librer칤as que uses en tu proyecto. Esto es muy util por ejemplo para realizar migraciones de base de datos. En una entrada futura te ense침ar칠 como hacerlo.

## Optimizando las im치genes en Next.js

La segunda parte de esta entrada la dedicaremos a usar apropiadamente las herramientas que Next nos provee en relaci칩n a las im치genes. Hasta ahora he estado esquivando el componente `Image` de Next puesto que requiere especificar el tama침o de la imag칠n y nadie tiene tiempo de tener un trabajo a tiempo completo, mantener un blog y medir las im치genes a la vez. Pero ahora que hemos autom치tizado el proceso, vamos a ver como podemos hacer uso de este componente para mostrar nuestras im치genes con lazy loading, placeholders y el tama침o correcto:

En nuestro archivo `mdx-content.tsx` es donde especificamos c칩mo transformamos el contenido markdown en elementos/componentes. Para las im치genes, estamos haciendo esto:

```tsx@components/mdx-content.tsx
const mdxComponents = {
  ...
    img: (props: any) => <img className="w-auto mb-1 m-auto" title={props.alt} alt={props.alt} src={props.src} />,
  ...
}
```

Cuando definimos una imag칠n en markdown, lo hacemos de la siguiente manera:

```markdown
![Texto alternativo](/images/nombre-de-la-imagen.webp)
```

En las props recibimos `Texto alternativo` como `props.alt` y `/images/nombre-de-la-imagen.webp` como `props.src`. Vamos a sustituir el componente `img` por el componente `Image` de Next:

```tsx@components/mdx-content.tsx
img: (props: any) => <Image
  className="w-auto mb-1 m-auto"
  alt={props.alt}
  src={props.src}
/>,
```

Para facilitar el uso de imagenes y dado que todas se almacenan en la misma carpeta, vamos a asumir que la ruta solo especifica el nombre de la imagen sin extensi칩n ni ruta:

```tsx@components/mdx-content.tsx
img: (props: any) => <Image
  className="w-auto mb-1 m-auto"
  alt={props.alt}
  src={`/images/${props.src}.webp`}
/>,
```

_Importante_: Este cambio me va a requerir refactorizar TODOS los posts. Por suerte para m칤, no tengo muchos 游땍.

Como `src` ahora es solo el nombre del archivo, coincide con la clave del objeto `json` que creamos en el script. Por lo que podemos usar esa informaci칩n para obtener el tama침o de la imagen y pas치rselo al componente `Image`:

```tsx@components/mdx-content.tsx
import imageSizes from '../public/images/image_sizes.json'

...

img: (props: any) => {
  const { width, height } = imageSizes[props.src as keyof typeof imageSizes]

  return <Image
    className="w-auto mb-1 m-auto"
    alt={props.alt}
    src={`/images/${props.src}.webp`}
    width={width}
    height={height}
  />
},
```

`keyof typeof` nos permite indicarle a Typescript que est칠 tranquilo, que `src` es una clave existente en el objeto imageSizes. De este modo estamos trasladando el error al tiempo de ejecuci칩n, lo cual no es necesariamente una buena pr치ctica. Pero en este caso se justifica por el hecho de que si la clave no existe, es porque la hemos escrito m치l. Si usamos una clave n칩 valida, esa linea romper치 ocn una excepci칩n en tiempo de construcci칩n, por lo que no corremos riesgo de mandar imagenes inexistentes al navegador y de hecho, con esto hemos mejorado nuestro flujo de trabajo: Si una imagen no existe, el script de `build` va a romper y con ello impedir치 que la pagina rota se despliegue.

Vamos a indicarle a **Next** que no queremos cargar la imagen hasta que no est칠 cerca de entrar en el viewport. Con esto evitamos cargar todas las im치genes al principio y solo las cargamos cuando estamos cerca de mostrarlas. Para ello, vamos a a침adir la propiedad `loading="lazy"` al componente `Image`:

```tsx@components/mdx-content.tsx
img: (props: any) => {
  const { width, height } = imageSizes[props.src as keyof typeof imageSizes]

  return <Image
    className="w-auto mb-1 m-auto"
    alt={props.alt}
    src={`/images/${props.src}.webp`}
    width={width}
    height={height}
    loading="lazy"
  />
},
```

Puedes ir a un post con muchas im치genes (Por ejemplo [este](/posts/primer-dia-datadog)), abrir el inspector de elementos, pesta침a _network_, filtrar por imagenes: Podr치s ver c칩mo las imagenes solo se van descargando conforme vas haciendo scroll y te acercas a que sean visibles:

![Cargando imagenes a demanda](image_loading)

Por 칰ltimo, vamos a a침adir el placeholder. Para ello, vamos a setear la propiedad `placeholder` a `blur` en el componente `Image`, y vamos especificar la ruta a la imagen que generamos anteriormente:

```tsx@components/mdx-content.tsx
    return <Image
      className="mb-1 m-auto"
      alt={props.alt}
      src={`/images/${props.src}.webp`}
      width={width}
      height={height}
      loading='lazy'
      placeholder='blur'
      blurDataURL={`/images/placeholder/${props.src}.webp`}
    />
```

Por 칰ltimo, voy a solucionar el tema de los pies de foto. Hasta ahora he venido poniendo un texto en cursiva debajo de la imagen. A parte de no quedar muy all치:

![Pie de foto](imagefoot)

Tiene el problema de que no es accesible. Las personas con problemas de visi칩n no van a poder saber que hay un pie de foto. Por lo que vamos a a침adir un `figcaption` a la imagen para dejar claro desde el punto de vista sem치ntico y no solo visual, que se trata de un pi칠 de foto:

```tsx@components/mdx-content.tsx
    return <figure>
      <Image
        ...
      />
      <figcaption className='text-xs text-center text-slate-300'>{props.alt}</figcaption>
    </figure>
  }
```

Comparando lo anterior con lo nuevo:

![Pie de foto](figcaption)

Luce mejor, pero tenemos dos problemas:

- Como se ve en el ejemplo, no siempre el alt y el pie de foto coinciden

- Si lo dejo as칤, voy a asumir que todas las imagenes van a tener pie de foto, y esto no es as칤 en este blog. Por lo que me obligar칤a a actualizar todos los posts. De nuevo, no son muchos pero no me apetece revisarlos todos.

Por lo que vamos a implementar un sistema que permita a침adir el pie de foto desde el markdown sin demasiada complicaci칩n. Las reglas serian:

- Si nos encontramos una `@` en el texto alternativo, la foto tendr치 pie de foto. De este modo nos aseguramos de no romper la compatibilidad con los posts anteriores.

- Si nos encontramos la `@`, el texto que la precede ser치 el `akt` y el vaya detr치s de ella ser치 el pie de foto.

- Si nos encontramos la `@` pero no hay texto detr치s, el `alt` y el pie de foto ser치n el mismo.

Modifico una vez m치s el componente para a침adir la l칩gica descrita:

```tsx@components/mdx-content.tsx
  img: (props: any) => {
    const { width, height } = imageSizes[props.src as keyof typeof imageSizes]
    const [alt, caption] = props.alt.split('@')

    const hasCaption = caption !== undefined

    return <figure>
      <Image
        ...
      />
      {hasCaption
        ? <figcaption className='text-xs text-center text-slate-300'>{
          caption || alt
        }</figcaption>
        : null
      }
    </figure>
  }
```

Y ahora puedo modificar el markdown de esto:

```markdown
![Imagen de Muzzy](muzzy)
_Elige uno y arranca tu carrera como web-developer_
```

A esto:

```markdown
![Imagen de Muzzy@Elige uno y arranca tu carrera como web-developer](muzzy)
```

Y disfrutar de esos lindos y sem치nticos pies de foto:

![Pie de foto](figcaption_fixed)

> **OJO!** remark por defecto envuelve todos los elementos en un p치rrafo, as칤 que con este cambio estamos metiendo un figure dentro de p, lo cual es sem치nticamente incorrecto y nos da errores de hydration al mandar la p치gina al cliente.
>
> He tenido que echar un par de horas investigando el asunto y no quiero explicarlo aqu칤 ya que el post se ha vuelto ya demasiado largo. TLDR: Puedes usar un plugin de remark para evitar este comportamiento con imagenes, lo cual limpia el problema de raiz. Tengo [este commit](https://github.com/FrBosquet/fran-bosquet/commit/df13951de3ced8b251398f629fd33c0e50785552) en el que implemento esta soluci칩n y actualizo next-mdx-remote para usar RSC, aprovechando que he migrado a Next 14.
>
> Por la misma raz칩n, tampoco me he extendido en como he utilizado chokidar para monitorizar la carpeta images y correr el script autom치ticamente cada vez que a침ado una imagen, o como he actualizado el linter para facilitarme el trabajo. Si tienes inter칠s, puedes checkear la PR en Github y ver todo lo que se ha quedado fuera de este post.

## Conclusi칩n

Hemos aprendido a automatizar una tarea muy tediosa como es preparar las im치genes para usarlas en la web. Hemos simplificado la interfaz en MDX para que usarlas sea los m치s sencillo y accesible posible. Hemos mejorado la experiencia de usuario con lazy loading y placeholders. Y finalmente hemos mejorado la accesibilidad de las im치genes a침adiendo pies de foto sem치nticos.

En el camino hemos aprendido a usar algunas herramientas de terminal muy interesantes y hemos mejorado nuestro entendimiento de Next.

Si has llegado hasta aqu칤 despu칠s de semejante ladrillo, te doy las gracias por tu tiempo y espero que te hayas llevado algo de provecho. Hasta la pr칩xima!
